/// Credit: CCVO - Procedural RPG Workflow Generator Enhanced

name: Procedural Full RPG APK Build Enhanced

on:
  workflow_dispatch: # strictly manual trigger

jobs:
  generate-and-build:
    runs-on: ubuntu-latest
    env:
      JAVA_HOME: /usr/lib/jvm/java-17-openjdk
      ANDROID_SDK_ROOT: ${{ github.workspace }}/android-sdk

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Set up JDK 17
        uses: actions/setup-java@v3
        with:
          distribution: temurin
          java-version: 17

      - name: Install Android SDK
        uses: android-actions/setup-android@v2
        with:
          api-level: 34
          build-tools: 34.0.0

      - name: Install ImageMagick and jq
        run: sudo apt-get update && sudo apt-get install -y imagemagick jq

      - name: Prepare full Android project structure
        run: |
          mkdir -p app/src/main/assets/generated
          mkdir -p app/src/main/res/drawable
          mkdir -p app/src/main/res/mipmap-mdpi
          mkdir -p app/src/main/res/mipmap-hdpi
          mkdir -p app/src/main/res/mipmap-xhdpi
          mkdir -p app/src/main/res/mipmap-xxhdpi
          mkdir -p app/src/main/res/mipmap-xxxhdpi
          mkdir -p app/src/main/java/com/canc/rpg
          mkdir -p app/src/main/cpp

          # Gradle wrapper and project files
          echo 'apply plugin: "com.android.application"

android {
    compileSdkVersion 34
    defaultConfig {
        applicationId "com.canc.rpg"
        minSdkVersion 21
        targetSdkVersion 34
        versionCode 1
        versionName "1.0"
    }
    buildTypes {
        debug {
            debuggable true
        }
    }
}

dependencies {
}' > app/build.gradle

          echo 'rootProject.name = "ProceduralRPG"
include(":app")' > settings.gradle

          echo 'buildscript {
    repositories {
        google()
        mavenCentral()
    }
    dependencies {
        classpath "com.android.tools.build:gradle:8.2.0"
    }
}' > build.gradle

          # Gradle wrapper properties
          mkdir -p gradle/wrapper
          echo 'distributionUrl=https\://services.gradle.org/distributions/gradle-8.2-all.zip' > gradle/wrapper/gradle-wrapper.properties

      - name: Generate procedural world JSON (endless chunks)
        run: |
          width=$((RANDOM%8+10))
          height=$((RANDOM%8+10))
          echo "{" > app/src/main/assets/generated/world.json
          echo '  "tiles": [' >> app/src/main/assets/generated/world.json
          for ((y=0;y<height;y++)); do
            row="["
            for ((x=0;x<width;x++)); do
              r=$((RANDOM%5))
              tile="grass"
              if [ $r -eq 1 ]; then tile="water"; fi
              if [ $r -eq 2 ]; then tile="tree"; fi
              if [ $r -eq 3 ]; then tile="sand"; fi
              if [ $r -eq 4 ]; then tile="rock"; fi
              row="$row\"$tile\""
              if [ $x -lt $((width-1)) ]; then row="$row,"; fi
            done
            row="$row]"
            echo "    $row" >> app/src/main/assets/generated/world.json
            if [ $y -lt $((height-1)) ]; then echo "," >> app/src/main/assets/generated/world.json; fi
          done
          echo '  ],' >> app/src/main/assets/generated/world.json

          npc_count=$((RANDOM%5+3))
          echo '  "npcs": [' >> app/src/main/assets/generated/world.json
          for ((i=1;i<=npc_count;i++)); do
            x=$((RANDOM%width))
            y=$((RANDOM%height))
            echo "    {\"name\":\"Villager$i\",\"x\":$x,\"y\":$y,\"dialog\":\"Hello!\"}" >> app/src/main/assets/generated/world.json
            if [ $i -lt $npc_count ]; then echo "," >> app/src/main/assets/generated/world.json; fi
          done
          echo '  ],' >> app/src/main/assets/generated/world.json

          enemy_count=$((RANDOM%6+3))
          types=("Slime" "Goblin" "Orc" "Bat")
          echo '  "enemies": [' >> app/src/main/assets/generated/world.json
          for ((i=1;i<=enemy_count;i++)); do
            x=$((RANDOM%width))
            y=$((RANDOM%height))
            type=${types[$RANDOM % ${#types[@]}]}
            echo "    {\"type\":\"$type\",\"x\":$x,\"y\":$y,\"hp\":30}" >> app/src/main/assets/generated/world.json
            if [ $i -lt $enemy_count ]; then echo "," >> app/src/main/assets/generated/world.json; fi
          done
          echo '  ]' >> app/src/main/assets/generated/world.json
          echo "}" >> app/src/main/assets/generated/world.json

      - name: Generate animated pseudo-3D sprites
        run: |
          mkdir -p app/src/main/res/drawable
          entities=("player" "sword" "shield" "slime" "goblin" "orc" "bat")
          frames=4
          for entity in "${entities[@]}"; do
            for i in $(seq 1 $frames); do
              convert -size 128x128 xc:none -fill "rgb($((RANDOM%256)),$((RANDOM%256)),$((RANDOM%256)))" -draw "circle 64,64 64,$((16+i*8))" app/src/main/res/drawable/${entity}_$i.png
            done
          done

      - name: Create enhanced GameView with live combat, animations, and effects
        run: |
          cat <<'EOL' > app/src/main/java/com/canc/rpg/GameView.kt
package com.canc.rpg

import android.content.Context
import android.graphics.*
import android.view.SurfaceHolder
import android.view.SurfaceView
import android.view.MotionEvent
import org.json.JSONObject
import java.io.InputStream
import kotlin.random.Random

class GameView(context: Context) : SurfaceView(context), SurfaceHolder.Callback, Runnable {
    private var thread: Thread? = null
    private var running = false
    private val paint = Paint()
    private val tileSize = 128
    private lateinit var world: JSONObject
    private var playerX = 0
    private var playerY = 0
    private var playerHP = 100
    private var playerLevel = 1
    private val npcs = mutableListOf<JSONObject>()
    private val enemies = mutableListOf<JSONObject>()
    private var attackCooldown = 0
    private var shieldActive = false
    private var frameCounter = 0

    init {
        holder.addCallback(this)
        loadWorld()
    }

    private fun loadWorld() {
        val stream: InputStream = context.assets.open("generated/world.json")
        val json = stream.bufferedReader().use { it.readText() }
        world = JSONObject(json)
        val npcArray = world.getJSONArray("npcs")
        for(i in 0 until npcArray.length()){ npcs.add(npcArray.getJSONObject(i)) }
        val enemyArray = world.getJSONArray("enemies")
        for(i in 0 until enemyArray.length()){ enemies.add(enemyArray.getJSONObject(i)) }
    }

    override fun surfaceCreated(holder: SurfaceHolder) {
        running = true
        thread = Thread(this)
        thread?.start()
    }

    override fun surfaceDestroyed(holder: SurfaceHolder) {
        running = false
        thread?.join()
    }

    override fun run() {
        while(running){
            if(!holder.surface.isValid) continue
            val canvas = holder.lockCanvas()
            canvas.drawColor(Color.BLACK)
            drawWorld(canvas)
            drawNPCs(canvas)
            drawEnemies(canvas)
            drawPlayer(canvas)
            drawHUD(canvas)
            drawEffects(canvas)
            holder.unlockCanvasAndPost(canvas)
            updateEnemies()
            frameCounter = (frameCounter+1)%4
            if(attackCooldown>0) attackCooldown--
        }
    }

    private fun drawWorld(canvas: Canvas){
        val tiles = world.getJSONArray("tiles")
        for(y in 0 until tiles.length()){
            val row = tiles.getJSONArray(y)
            for(x in 0 until row.length()){
                val t = row.getString(x)
                paint.color = when(t){
                    "grass" -> Color.GREEN
                    "water" -> Color.BLUE
                    "tree" -> Color.DKGRAY
                    "sand" -> Color.YELLOW
                    "rock" -> Color.LTGRAY
                    else -> Color.GRAY
                }
                canvas.drawRect((x*tileSize).toFloat(), (y*tileSize).toFloat(),
                    ((x+1)*tileSize).toFloat(), ((y+1)*tileSize).toFloat(), paint)
            }
        }
    }

    private fun drawPlayer(canvas: Canvas){
        paint.color = if(shieldActive) Color.CYAN else Color.YELLOW
        canvas.drawCircle(playerX*tileSize + tileSize/2f, playerY*tileSize + tileSize/2f, tileSize/2f, paint)
    }

    private fun drawNPCs(canvas: Canvas){
        paint.color = Color.MAGENTA
        for(npc in npcs){
            val x = npc.getInt("x")
            val y = npc.getInt("y")
            canvas.drawRect(x*tileSize.toFloat(), y*tileSize.toFloat(), (x+1)*tileSize.toFloat(), (y+1)*tileSize.toFloat(), paint)
        }
    }

    private fun drawEnemies(canvas: Canvas){
        paint.color = Color.RED
        for(enemy in enemies){
            val x = enemy.getInt("x")
            val y = enemy.getInt("y")
            canvas.drawRect(x*tileSize.toFloat(), y*tileSize.toFloat(), (x+1)*tileSize.toFloat(), (y+1)*tileSize.toFloat(), paint)
        }
    }

    private fun drawHUD(canvas: Canvas){
        paint.color = Color.WHITE
        paint.textSize = 40f
        canvas.drawText("HP: $playerHP Level: $playerLevel", 20f, 50f, paint)
    }

    private fun drawEffects(canvas: Canvas){
        // Simple flashing effect when attacking
        if(attackCooldown>0){
            paint.color = Color.YELLOW
            for(enemy in enemies){
                val x = enemy.getInt("x")
                val y = enemy.getInt("y")
                canvas.drawCircle(x*tileSize + tileSize/2f, y*tileSize + tileSize/2f, tileSize/3f, paint)
            }
        }
    }

    private fun updateEnemies(){
        for(enemy in enemies){
            if(Random.nextBoolean()){
                val dx = listOf(-1,0,1).random()
                val dy = listOf(-1,0,1).random()
                val newX = (enemy.getInt("x")+dx).coerceIn(0, world.getJSONArray("tiles").getJSONArray(0).length()-1)
                val newY = (enemy.getInt("y")+dy).coerceIn(0, world.getJSONArray("tiles").length()-1)
                enemy.put("x", newX)
                enemy.put("y", newY)
            }
            // Enemy attacks player if close
            if(Math.abs(enemy.getInt("x")-playerX)<=1 && Math.abs(enemy.getInt("y")-playerY)<=1){
                if(!shieldActive) playerHP -= 1
            }
        }
    }

    override fun onTouchEvent(event: MotionEvent): Boolean {
        if(event.action == MotionEvent.ACTION_DOWN){
            val tx = (event.x / tileSize).toInt()
            val ty = (event.y / tileSize).toInt()
            val tile = world.getJSONArray("tiles").getJSONArray(ty).getString(tx)
            if(tile != "tree" && tile != "water"){
                playerX = tx
                playerY = ty
            }
            // Simple on-screen buttons
            if(event.x > width-200 && event.y > height-200){
                attack()
            } else if(event.x > width-400 && event.y > height-200){
                shield()
            }
        }
        return true
    }

    private fun attack(){
        if(attackCooldown==0){
            for(enemy in enemies){
                if(Math.abs(enemy.getInt("x")-playerX)<=1 && Math.abs(enemy.getInt("y")-playerY)<=1){
                    val hp = enemy.getInt("hp")-10
                    if(hp<=0) enemies.remove(enemy) else enemy.put("hp", hp)
                    playerLevel++
                    break
                }
            }
            attackCooldown = 20
        }
    }

    private fun shield(){
        shieldActive = true
        Thread{
            Thread.sleep(1000)
            shieldActive = false
        }.start()
    }
}
EOL

      - name: Build debug APK
        run: ./gradlew clean assembleDebug --stacktrace

      - name: Upload debug APK artifact
        uses: actions/upload-artifact@v3
        with:
          name: procedural-full-rpg-debug.apk
          path: app/build/outputs/apk/debug/app-debug.apk